map "http://research.balgrist.ch/fhir2sphn/StructureMap/ObservationSurveyToAssessmentEvent" = "ObservationSurveyToAssessmentEvent"

// Source definitions
uses "http://hl7.org/fhir/StructureDefinition/Observation" alias Observation as source
uses "http://hl7.org/fhir/StructureDefinition/Quantity" alias Quantity as source

// Target definitions
uses "http://research.balgrist.ch/fhir2sphn/StructureDefinition/Content" alias Content as target
uses "http://research.balgrist.ch/fhir2sphn/StructureDefinition/AssessmentResult" alias AssessmentResult as target
uses "http://research.balgrist.ch/fhir2sphn/StructureDefinition/AssessmentComponent" alias AssessmentComponent as target
uses "http://research.balgrist.ch/fhir2sphn/StructureDefinition/Assessment" alias Assessment as target
uses "http://research.balgrist.ch/fhir2sphn/StructureDefinition/AssessmentEvent" alias AssessmentEvent as target

imports "http://research.balgrist.ch/fhir2sphn/StructureMap/Utils"

// Utils
group resultValueQuantityToAssessmentResult(source vq: Quantity, target assessment: Assessment){
 vq -> assessment.hasResult = create('AssessmentResult') as result, result.id = uuid(), result.hasQuantity as q then quantity(vq, q) "AssessmentResult";
}

group codingToCode(source coding, target trg){
 coding as srcCoding where $this.system = 'http://snomed.info/sct' -> trg.hasCode as trgCode then {
   srcCoding.code as c -> trgCode.termid = c as termid,
   trgCode.iri = append('http://snomed.info/id/', termid);
 } "codingToCode";
}

// Helper to populate Assessment result from observation
// Note: Uses polymorphic obs.value access since obs.valueQuantity/obs.valueCodeableConcept
// don't resolve correctly when observation is passed as a group parameter
group populateAssessmentResult(source obs: Observation, target assessment: Assessment) {
  // value[x] as CodeableConcept -> AssessmentResult/hasCode
  obs.value as vcc where $this.is(CodeableConcept) -> assessment.hasResult = create('AssessmentResult') as result, result.id = uuid() then {
    vcc.coding as coding -> result then codingToCode(coding, result);
    // valueCodeableConcept/extension/ValueQuantity -> Assessment/hasQuantity
    vcc.extension as ext where $this.url = "https://www.hl7.org/fhir/R4/observation.html#component/valueQuantity" then {
      ext.valueQuantity as vq -> assessment then resultValueQuantityToAssessmentResult(vq, assessment);
    };
  } "valueCodeableConcept";

  // value[x] as Quantity -> AssessmentResult/hasQuantity
  obs.value as vq where $this.is(Quantity) -> assessment.hasResult = create('AssessmentResult') as result, result.id = uuid(), result.hasQuantity as q then quantity(vq, q) "valueQuantity";

  // value[x] as String -> AssessmentResult/hasStringValue
  obs.value as vs where $this.is(string) -> assessment.hasResult = create('AssessmentResult') as result, result.id = uuid(), result.hasStringValue = vs "valueString";
}

// Main mapping Observation -> AssessmentEvent
group assessmentEvent(source observation : Observation, target content : Content) <<types>> {
 observation -> content.AssessmentEvent = create('AssessmentEvent') as assessmentEvent then {
   // Metadata and basic fields
   observation.meta as m then refSourceSystem(m, assessmentEvent);
   observation.id as id -> assessmentEvent.id = ('AssessmentEvent/' & %id);
   observation.effectiveDateTime as t -> assessmentEvent.hasDateTime = t;
   observation.encounter as encounter -> assessmentEvent.hasAdministrativeCase = encounter;

   // observation.code -> Assessment
   observation.code as observation_code -> assessmentEvent.hasAssessment = create('Assessment') as assessment, assessment.id = uuid() then {
     observation_code.coding as coding -> assessment then codingToCode(coding, assessment);
     // hasName: prefer observation_code.text, fallback to coding.display
     observation_code.text as t -> assessment.hasName = t;
     observation_code where $this.text.exists().not() then {
       observation_code.coding as coding then {
         coding.display as d -> assessment.hasName = d;
       } "hasNameFromDisplay";
     } "hasNameFallback";

     // Populate assessment result (valueCodeableConcept or valueQuantity)
     observation -> assessment then populateAssessmentResult(observation, assessment) "assessmentResult";
 
     // Component -> Assessment/Component
     observation.component as comp -> assessment.hasComponent = create('AssessmentComponent') as component, component.id = uuid() then {
       // coding -> Components/hasCode
       comp.code as srcCode then {
         srcCode.coding as coding -> component then codingToCode(coding, component);
         // hasName: prefer srcCode.text, fallback to coding.display
         srcCode.text as t -> component.hasName = t;
         srcCode where $this.text.exists().not() then {
           srcCode.coding as coding then {
             coding.display as d -> component.hasName = d;
           } "componentHasNameFromDisplay";
         } "componentHasNameFallback";
       };

       // Component results
       //  valueCodeableConcept
       comp.valueCodeableConcept as vcc -> component.hasResult = create('AssessmentResult') as result, result.id = uuid() then {
         vcc.coding as coding -> result then codingToCode(coding, result);
       
         // valueQuantity extension
         vcc.extension as ext where $this.url = "https://www.hl7.org/fhir/R4/observation.html#component/valueQuantity" then {
           ext.valueQuantity as vq -> component then resultValueQuantityToAssessmentResult(vq, component);
         };
       } "compValueCodeableConcept";
       
       // Standalone valueQuantity
       comp.valueQuantity as vq -> component then resultValueQuantityToAssessmentResult(vq, component);

       // Standalone valueString
       comp.valueString as vs -> component.hasResult = create('AssessmentResult') as result, result.id = uuid(), result.hasStringValue = vs "compValueString";

     } "AssessmentComponent";
   } "Assessment";
 } "AssessmentEvent";
}